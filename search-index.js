var searchIndex = {};
searchIndex["scaproust"] = {"doc":"Scaproust is an implementation of the nanomsg \"Scalability Protocols\" in the Rust programming language.","items":[[3,"SessionBuilder","scaproust","Creates the session and starts the I/O thread.",null,null],[3,"Session","","Creates sockets and devices.",null,null],[3,"Socket","","Socket is what applications use to exchange messages.",null,null],[3,"Probe","","Probe is what applications use to poll sockets.",null,null],[3,"Endpoint","","Endpoint of a socket.",null,null],[3,"Ipc","","",null,null],[4,"ConfigOption","","",null,null],[13,"Linger","","Specifies how long the socket should try to send pending outbound messages after `drop` have been called. Default value is 1 second.",0,null],[13,"SendTimeout","","See Socket::set_send_timeout.",0,null],[13,"SendPriority","","See Socket::set_send_priority.",0,null],[13,"RecvTimeout","","See Socket::set_recv_timeout.",0,null],[13,"RecvPriority","","See Socket::set_recv_priority.",0,null],[13,"RecvMaxSize","","Maximum message size that can be received, in bytes. Zero value means that the received size is limited only by available addressable memory.  Default is 1024kB.",0,null],[13,"RetryIvl","","For connection-based transports such as TCP, this option specifies how long to wait, when connection is broken before trying to re-establish it.  Note that actual reconnect interval may be randomised to some extent  to prevent severe reconnection storms. Default value is 0.1 second.",0,null],[13,"RetryIvlMax","","This option is to be used only in addition to ReconnectInterval option. It specifies maximum reconnection interval. On each reconnect attempt, the previous interval is doubled until ReconnectIntervalMax is reached. Value of `None` means that no exponential backoff is performed and reconnect interval is based only on ReconnectInterval. If RetryIvlMax is less than RetryIvl, it is ignored.  Default value is `None`.",0,null],[13,"TcpNoDelay","","See Socket::set_tcp_nodelay.",0,null],[13,"Subscribe","","Defined on `Sub` socket. Subscribes for a particular topic. A single `Sub` socket can handle multiple subscriptions.",0,null],[13,"Unsubscribe","","Defined on Sub` socket. Unsubscribes from a particular topic.",0,null],[13,"ReqResendIvl","","This option is defined on the Req socket. If a reply is not received in the specified amount of time,  the request will be automatically resent.  Default value is 1 minute.",0,null],[13,"SurveyDeadline","","Specifies how long to wait for responses to the survey. Once the deadline expires, receive function will return a TimedOut error  and all subsequent responses to the survey will be silently dropped. Default value is 1 second.",0,null],[0,"core","","",null,null],[3,"PollReq","scaproust::core","Request for socket polling, tells whether the poll should wait for the socket to become readable or writable.",null,null],[12,"sid","","",1,null],[12,"recv","","",1,null],[12,"send","","",1,null],[3,"PollRes","","Result of a socket polling, tells whether the socket is readable or writable.",null,null],[12,"recv","","",2,null],[12,"send","","",2,null],[3,"Message","","",null,null],[12,"header","","",3,null],[12,"body","","",3,null],[3,"IdHasher","","",null,null],[3,"BuildIdHasher","","",null,null],[11,"default","","",3,{"inputs":[],"output":{"name":"message"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",3,{"inputs":[],"output":{"name":"message"}}],[11,"from_body","","",3,{"inputs":[{"name":"vec"}],"output":{"name":"message"}}],[11,"from_header_and_body","","",3,{"inputs":[{"name":"vec"},{"name":"vec"}],"output":{"name":"message"}}],[11,"len","","",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get_header","","",3,null],[11,"get_body","","",3,null],[11,"split","","",3,null],[11,"without_header","","",3,{"inputs":[{"name":"self"}],"output":{"name":"message"}}],[11,"into","","",3,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"from","","",3,{"inputs":[{"name":"vec"}],"output":{"name":"message"}}],[11,"default","","",4,{"inputs":[],"output":{"name":"idhasher"}}],[11,"finish","","",4,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"write_u64","","",4,{"inputs":[{"name":"self"},{"name":"u64"}],"output":null}],[11,"write","","",4,null],[11,"write_u8","","",4,{"inputs":[{"name":"self"},{"name":"u8"}],"output":null}],[11,"write_u16","","",4,{"inputs":[{"name":"self"},{"name":"u16"}],"output":null}],[11,"write_u32","","",4,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"write_usize","","",4,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"write_i8","","",4,{"inputs":[{"name":"self"},{"name":"i8"}],"output":null}],[11,"write_i16","","",4,{"inputs":[{"name":"self"},{"name":"i16"}],"output":null}],[11,"write_i32","","",4,{"inputs":[{"name":"self"},{"name":"i32"}],"output":null}],[11,"write_i64","","",4,{"inputs":[{"name":"self"},{"name":"i64"}],"output":null}],[11,"write_isize","","",4,{"inputs":[{"name":"self"},{"name":"isize"}],"output":null}],[11,"default","","",5,{"inputs":[],"output":{"name":"buildidhasher"}}],[11,"build_hasher","","",5,{"inputs":[{"name":"self"}],"output":{"name":"idhasher"}}],[0,"proto","scaproust","Scalability protocols provided by scaproust",null,null],[0,"pair","scaproust::proto","",null,null],[3,"Pair","scaproust::proto::pair","",null,null],[0,"push","scaproust::proto","",null,null],[3,"Push","scaproust::proto::push","",null,null],[11,"from","","",6,{"inputs":[{"name":"sender"}],"output":{"name":"push"}}],[0,"pull","scaproust::proto","",null,null],[3,"Pull","scaproust::proto::pull","",null,null],[11,"from","","",7,{"inputs":[{"name":"sender"}],"output":{"name":"pull"}}],[0,"req","scaproust::proto","",null,null],[3,"Req","scaproust::proto::req","",null,null],[11,"from","","",8,{"inputs":[{"name":"sender"}],"output":{"name":"req"}}],[0,"rep","scaproust::proto","",null,null],[3,"Rep","scaproust::proto::rep","",null,null],[11,"from","","",9,{"inputs":[{"name":"sender"}],"output":{"name":"rep"}}],[0,"publ","scaproust::proto","",null,null],[3,"Pub","scaproust::proto::publ","",null,null],[11,"from","","",10,{"inputs":[{"name":"sender"}],"output":{"name":"pub"}}],[0,"sub","scaproust::proto","",null,null],[3,"Sub","scaproust::proto::sub","",null,null],[11,"from","","",11,{"inputs":[{"name":"sender"}],"output":{"name":"sub"}}],[0,"surv","scaproust::proto","",null,null],[3,"Surveyor","scaproust::proto::surv","",null,null],[11,"from","","",12,{"inputs":[{"name":"sender"}],"output":{"name":"surveyor"}}],[0,"resp","scaproust::proto","",null,null],[3,"Respondent","scaproust::proto::resp","",null,null],[11,"from","","",13,{"inputs":[{"name":"sender"}],"output":{"name":"respondent"}}],[0,"bus","scaproust::proto","",null,null],[3,"Bus","scaproust::proto::bus","",null,null],[11,"from","","",14,{"inputs":[{"name":"sender"}],"output":{"name":"bus"}}],[17,"PAIR","scaproust::proto","**One-to-one protocol**",null,null],[17,"PUB","","**Publish/subscribe protocol**",null,null],[17,"SUB","","**Publish/subscribe protocol**",null,null],[17,"REQ","","**Request/reply protocol**",null,null],[17,"REP","","**Request/reply protocol**",null,null],[17,"PUSH","","**Pipeline protocol**",null,null],[17,"PULL","","**Pipeline protocol**",null,null],[17,"SURVEYOR","","**Survey protocol**",null,null],[17,"RESPONDENT","","**Survey protocol**",null,null],[17,"BUS","","**Message bus protocol**",null,null],[0,"transport","scaproust","",null,null],[3,"Destination","scaproust::transport","",null,null],[12,"addr","","",15,null],[12,"pids","","",15,null],[12,"tcp_no_delay","","",15,null],[12,"recv_max_size","","",15,null],[0,"async","","",null,null],[3,"AsyncPipe","scaproust::transport::async","",null,null],[0,"stub","","This module provides a pipe implementation built upon mio async streams.",null,null],[5,"send_and_check_handshake","scaproust::transport::async::stub","",null,null],[5,"recv_and_check_handshake","","",null,null],[8,"AsyncPipeStub","","",null,null],[8,"Sender","","",null,null],[10,"start_send","","",16,{"inputs":[{"name":"self"},{"name":"rc"}],"output":{"name":"result"}}],[10,"resume_send","","",16,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[10,"has_pending_send","","",16,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[8,"Receiver","","",null,null],[10,"start_recv","","",17,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[10,"resume_recv","","",17,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[10,"has_pending_recv","","",17,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[8,"Handshake","","",null,null],[10,"send_handshake","","",18,null],[10,"recv_handshake","","",18,null],[8,"WriteBuffer","","",null,null],[10,"write_buffer","","",19,null],[8,"ReadBuffer","","",null,null],[10,"read_buffer","","",20,null],[11,"new","scaproust::transport::async","",21,null],[11,"ready","","",21,{"inputs":[{"name":"self"},{"name":"context"},{"name":"ready"}],"output":null}],[11,"open","","",21,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[11,"close","","",21,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[11,"send","","",21,{"inputs":[{"name":"self"},{"name":"context"},{"name":"rc"}],"output":null}],[11,"recv","","",21,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[0,"tcp","scaproust::transport","",null,null],[3,"Tcp","scaproust::transport::tcp","",null,null],[11,"connect","","",22,{"inputs":[{"name":"self"},{"name":"destination"}],"output":{"name":"result"}}],[11,"bind","","",22,{"inputs":[{"name":"self"},{"name":"destination"}],"output":{"name":"result"}}],[0,"ipc","scaproust::transport","",null,null],[3,"Ipc","scaproust::transport::ipc","",null,null],[11,"connect","scaproust","",23,{"inputs":[{"name":"self"},{"name":"destination"}],"output":{"name":"result"}}],[11,"bind","","",23,{"inputs":[{"name":"self"},{"name":"destination"}],"output":{"name":"result"}}],[0,"endpoint","scaproust::transport","",null,null],[8,"EndpointRegistrar","scaproust::transport::endpoint","",null,null],[10,"register","","",24,{"inputs":[{"name":"self"},{"name":"evented"},{"name":"ready"},{"name":"pollopt"}],"output":null}],[10,"reregister","","",24,{"inputs":[{"name":"self"},{"name":"evented"},{"name":"ready"},{"name":"pollopt"}],"output":null}],[10,"deregister","","",24,{"inputs":[{"name":"self"},{"name":"evented"}],"output":null}],[0,"pipe","scaproust::transport","",null,null],[4,"Command","scaproust::transport::pipe","",null,null],[13,"Open","","",25,null],[13,"Close","","",25,null],[13,"Send","","",25,null],[13,"Recv","","",25,null],[4,"Event","","",null,null],[13,"Opened","","",26,null],[13,"Closed","","",26,null],[13,"CanSend","","",26,null],[13,"CanRecv","","",26,null],[13,"Sent","","",26,null],[13,"Received","","",26,null],[13,"Error","","",26,null],[8,"Pipe","","",null,null],[10,"ready","","",27,{"inputs":[{"name":"self"},{"name":"context"},{"name":"ready"}],"output":null}],[10,"open","","",27,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[10,"close","","",27,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[10,"send","","",27,{"inputs":[{"name":"self"},{"name":"context"},{"name":"rc"}],"output":null}],[10,"recv","","",27,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[8,"Context","","",null,null],[10,"raise","","",28,{"inputs":[{"name":"self"},{"name":"event"}],"output":null}],[11,"fmt","","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"name","","",26,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[0,"acceptor","scaproust::transport","",null,null],[4,"Command","scaproust::transport::acceptor","",null,null],[13,"Open","","",29,null],[13,"Close","","",29,null],[4,"Event","","",null,null],[13,"Opened","","",30,null],[13,"Closed","","",30,null],[13,"Accepted","","",30,null],[13,"Error","","",30,null],[8,"Acceptor","","",null,null],[10,"ready","","",31,{"inputs":[{"name":"self"},{"name":"context"},{"name":"ready"}],"output":null}],[10,"open","","",31,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[10,"close","","",31,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[8,"Context","","",null,null],[10,"raise","","",32,{"inputs":[{"name":"self"},{"name":"event"}],"output":null}],[8,"Transport","scaproust::transport","",null,null],[10,"connect","","",33,{"inputs":[{"name":"self"},{"name":"destination"}],"output":{"name":"result"}}],[10,"bind","","",33,{"inputs":[{"name":"self"},{"name":"destination"}],"output":{"name":"result"}}],[11,"default","scaproust","",34,{"inputs":[],"output":{"name":"sessionbuilder"}}],[11,"new","","",34,{"inputs":[],"output":{"name":"sessionbuilder"}}],[11,"with","","",34,{"inputs":[{"name":"self"},{"name":"str"},{"name":"t"}],"output":{"name":"sessionbuilder"}}],[11,"build","","",34,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"create_socket","","Creates a socket with the specified protocol, which in turn determines its exact semantics. See the proto module for a list of built-in protocols. The newly created socket is initially not associated with any endpoints. In order to establish a message flow at least one endpoint has to be added to the socket  using connect and bind methods.",35,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"create_relay_device","","Creates a loopback device that loops and sends any messages received from the socket back to itself.",35,{"inputs":[{"name":"self"},{"name":"socket"}],"output":{"name":"result"}}],[11,"create_bridge_device","","Creates a bridge device to forward messages between two sockets. It loops and sends any messages received from `left` to `right` and vice versa.",35,{"inputs":[{"name":"self"},{"name":"socket"},{"name":"socket"}],"output":{"name":"result"}}],[11,"create_probe","","Creates a probe for polling sockets",35,{"inputs":[{"name":"self"},{"name":"vec"}],"output":{"name":"result"}}],[11,"drop","","",35,{"inputs":[{"name":"self"}],"output":null}],[11,"create_poll_req","","Creates a poll request that can be used to initialize a probe. The probe will then allow polling a group of sockets",36,{"inputs":[{"name":"self"},{"name":"bool"},{"name":"bool"}],"output":{"name":"pollreq"}}],[11,"connect","","Adds a remote endpoint to the socket. The library would then try to connect to the specified remote endpoint. The addr argument consists of two parts as follows: `transport://address`. The transport specifies the underlying transport protocol to use. The meaning of the address part is specific to the underlying transport protocol. Note that bind and connect may be called multiple times on the same socket, thus allowing the socket to communicate with multiple heterogeneous endpoints. On success, returns an Endpoint that can be later used to remove the endpoint from the socket.",36,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"bind","","Adds a local endpoint to the socket. The endpoint can be then used by other applications to connect to. The addr argument consists of two parts as follows: `transport://address`. The transport specifies the underlying transport protocol to use. The meaning of the address part is specific to the underlying transport protocol. Note that bind and connect may be called multiple times on the same socket, thus allowing the socket to communicate with multiple heterogeneous endpoints. On success, returns an Endpoint that can be later used to remove the endpoint from the socket.",36,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"send","","Sends a buffer. Which of the peers the buffer will be sent to is determined by the protocol.",36,{"inputs":[{"name":"self"},{"name":"vec"}],"output":{"name":"result"}}],[11,"send_msg","","Sends a message. Which of the peers the message will be sent to is determined by the protocol.",36,{"inputs":[{"name":"self"},{"name":"message"}],"output":{"name":"result"}}],[11,"try_send","","Non-blocking version of the send method.",36,{"inputs":[{"name":"self"},{"name":"vec"}],"output":{"name":"result"}}],[11,"try_send_msg","","Non-blocking version of the send_msg method.",36,{"inputs":[{"name":"self"},{"name":"message"}],"output":{"name":"result"}}],[11,"recv","","Receives a buffer.",36,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"recv_msg","","Receives a message.",36,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"try_recv","","Non-blocking version of the recv method.",36,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"try_recv_msg","","Non-blocking version of the recv_msg method.",36,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"set_send_timeout","","Sets the timeout for send operation on the socket. If message cannot be sent within the specified timeout,  an error with the kind `TimedOut` is returned.  None means infinite timeout. Default value is `None`.",36,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"result"}}],[11,"set_recv_timeout","","Sets the timeout for recv operation on the socket. If message cannot be received within the specified timeout,  an error with the kind `TimedOut` is returned.  `None` value means infinite timeout. Default value is `None`.",36,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"result"}}],[11,"set_send_priority","","Sets outbound priority for endpoints subsequently added to the socket. This option has no effect on socket types that send messages to all the peers.   However, if the socket type sends each message to a single peer (or a limited set of peers),  peers with high priority take precedence over peers with low priority.  Highest priority is 1, lowest priority is 16. Default value is 8.",36,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"result"}}],[11,"set_recv_priority","","Sets inbound priority for endpoints subsequently added to the socket. This option has no effect on socket types that are not able to receive messages.   When receiving a message, messages from peer with higher priority  are received before messages from peer with lower priority.  Highest priority is 1, lowest priority is 16. Default value is 8.",36,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"result"}}],[11,"set_tcp_nodelay","","This option, when set to `true`, disables Nagle’s algorithm. It also disables delaying of TCP acknowledgments.  Using this option improves latency at the expense of throughput. Default value is `false`.",36,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"set_option","","Sets a socket option. See ConfigOption to get the list of options.",36,{"inputs":[{"name":"self"},{"name":"configoption"}],"output":{"name":"result"}}],[11,"drop","","",36,{"inputs":[{"name":"self"}],"output":null}],[11,"close","","",37,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"poll","","Checks the sockets and reports whether it’s possible to send a message to the socket and/or receive a message from each socket. Returns a vector of PollRes, one for each PollReq provided a build time.",38,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"result"}}],[11,"drop","","",38,{"inputs":[{"name":"self"}],"output":null}],[8,"Device","","A device to forward messages between sockets, working like a message broker. It can be used to build complex network topologies.",null,null],[10,"run","","This function loops until it hits an error. To break the loop and make the `run` function exit,  drop the session that created the device.",39,{"inputs":[{"name":"box"}],"output":{"name":"result"}}]],"paths":[[4,"ConfigOption"],[3,"PollReq"],[3,"PollRes"],[3,"Message"],[3,"IdHasher"],[3,"BuildIdHasher"],[3,"Push"],[3,"Pull"],[3,"Req"],[3,"Rep"],[3,"Pub"],[3,"Sub"],[3,"Surveyor"],[3,"Respondent"],[3,"Bus"],[3,"Destination"],[8,"Sender"],[8,"Receiver"],[8,"Handshake"],[8,"WriteBuffer"],[8,"ReadBuffer"],[3,"AsyncPipe"],[3,"Tcp"],[3,"Ipc"],[8,"EndpointRegistrar"],[4,"Command"],[4,"Event"],[8,"Pipe"],[8,"Context"],[4,"Command"],[4,"Event"],[8,"Acceptor"],[8,"Context"],[8,"Transport"],[3,"SessionBuilder"],[3,"Session"],[3,"Socket"],[3,"Endpoint"],[3,"Probe"],[8,"Device"]]};
initSearch(searchIndex);
